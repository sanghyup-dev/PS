# 힙 정렬

## 개요

기본적으로 선택정렬을 거꾸로 진행(최댓값을 찾아 가장 뒤로 보냄)

최댓값을 빠르게 찾는 구조인 힙을 활용하여 최댓값 칮기를 O(n)에서 O(logN)으로 감소

## 이진 트리란

모든 노드가 최대 2개의 자식만 갖는 트리

배열로 효율적으로 구현 가능
→ 인덱스 i에 대해

- 왼쪽 자식: 2i
- 오른쪽 자식: 2i + 1

>| 용어      | 의미             |
>| ------- | -------------- |
>| 노드      | 트리의 각 지점       |
>| 루트 노드   | 트리의 최상단 노드     |
>| 부모 / 자식 | 연결된 두 노드의 관계   |
>| 차수      | 한 노드가 가진 자식 수  |
>| 깊이      | 루트에서부터의 거리     |
>| 높이      | 트리 전체 깊이 중 최댓값 |
>| 리프 노드   | 자식이 없는 노드      |

## Max-Heap이란

힙: 완전 이진 트리 형태의 자료구조 (왼쪽부터 차곡차곡 채워진 이진 트리)

맥스 힙: 모든 부모 노드 ≥ 자식 노드를 만족하는 트리 (항상 루트 노드가 최댓값)

## Max-Heap 만드는 법 (Build Heap)

[예시 배열]
[5, 3, 6, 4, 7, 8, 9]

절차

- 배열을 트리 형태로 나열
- n/2번째 노드부터 1번째까지 차례로 heapify 수행

heapify 과정

- 현재 노드 i, 왼쪽 자식 2i, 오른쪽 자식 2i+1 중 가장 큰 값 → largest
- largest ≠ i면, i와 largest 위치의 값 교환 후, 다시 heapify(largest) 수행

결과

- 루트 노드에 전체 중 최댓값이 위치하게 됨
- 전체 구조는 max-heap 조건을 만족

## 힙 정렬 수행 절차
1. Max-Heap 구성
2. 루트 노드(최댓값)와 마지막 노드(n번째) 교환
3. heapify(1) 수행 → 다시 max-heap 유지
4. n을 1 줄이고 2~3 반복
5. n이 1이 될 때까지 반복하면 오름차순 정렬 완료

## 시간복잡도 분석

| 단계              | 소요 시간        |
| --------------- | ------------ |
| Max-Heap 생성     | O(N)         |
| heapify 반복 (N회) | O(NlogN)     |
| **총합**          | **O(NlogN)** |


공간복잡도는 O(1) (추가 배열 없이 정렬 수행 가능)

